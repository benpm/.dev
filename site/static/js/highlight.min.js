/*! highlight.js - Custom minimal implementation for syntax highlighting */
(function() {
  var hljs = {
    highlightAll: function() {
      var blocks = document.querySelectorAll('pre code');
      blocks.forEach(function(block) {
        hljs.highlightElement(block);
      });
    },
    
    highlightElement: function(element) {
      // Skip if already highlighted
      if (element.classList.contains('hljs')) return;
      
      var language = '';
      if (element.className) {
        var matches = element.className.match(/(?:^|\s)(python|javascript|c|cpp|rust|nim)(?:\s|$)/);
        if (matches) {
          language = matches[1];
        }
      }
      
      var code = element.textContent;
      var highlighted = hljs.highlight(code, language);
      element.innerHTML = highlighted;
      element.classList.add('hljs');
    },
    
    highlight: function(code, lang) {
      // First, escape HTML entities
      var result = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Define language-specific patterns
      var patterns = [];
      
      // Comments - handle before other patterns
      if (lang === 'python') {
        patterns.push({ regex: /(#[^\n]*)/g, className: 'hljs-comment' });
      }
      if (['javascript', 'c', 'cpp', 'rust'].indexOf(lang) !== -1) {
        patterns.push({ regex: /(\/\/[^\n]*)/g, className: 'hljs-comment' });
        patterns.push({ regex: /(\/\*[\s\S]*?\*\/)/g, className: 'hljs-comment' });
      }
      
      // Strings - must be before keywords
      patterns.push({ regex: /("(?:[^"\\]|\\.)*")/g, className: 'hljs-string' });
      patterns.push({ regex: /('(?:[^'\\]|\\.)*')/g, className: 'hljs-string' });
      if (lang === 'javascript') {
        patterns.push({ regex: /(`(?:[^`\\]|\\.)*`)/g, className: 'hljs-string' });
      }
      
      // Numbers
      patterns.push({ regex: /\b(\d+\.?\d*)\b/g, className: 'hljs-number' });
      
      // Language-specific keywords
      var keywords = {
        python: 'def|class|import|from|as|if|elif|else|for|while|return|yield|try|except|finally|with|lambda|pass|break|continue|and|or|not|in|is|None|True|False|print|async|await',
        javascript: 'var|let|const|function|class|import|export|from|if|else|for|while|return|yield|try|catch|finally|async|await|new|this|super|extends|static|break|continue|switch|case|default|typeof|instanceof|void|delete|in|of|null|undefined|true|false|console',
        c: 'int|char|float|double|void|long|short|unsigned|signed|struct|union|enum|typedef|static|extern|const|volatile|auto|register|sizeof|if|else|for|while|do|switch|case|default|break|continue|return|goto|include|define|ifdef|ifndef|endif|printf|scanf|malloc|free',
        cpp: 'int|char|float|double|void|long|short|unsigned|signed|bool|class|struct|union|enum|typedef|static|extern|const|volatile|auto|register|sizeof|public|private|protected|virtual|override|final|namespace|using|template|typename|if|else|for|while|do|switch|case|default|break|continue|return|goto|new|delete|this|nullptr|true|false|try|catch|throw|include|define|ifdef|ifndef|endif|std|cout|cin|endl',
        rust: 'fn|let|mut|const|static|struct|enum|trait|impl|type|use|mod|pub|crate|super|self|Self|if|else|match|loop|for|while|break|continue|return|unsafe|async|await|dyn|where|move|ref|as|in|true|false|Some|None|Ok|Err|String|Vec|Option|Result',
        nim: 'proc|func|method|template|macro|var|let|const|type|object|enum|tuple|ref|ptr|seq|array|set|if|elif|else|when|case|of|for|while|block|break|continue|return|yield|discard|try|except|finally|raise|echo|true|false|nil|and|or|not|in|is|as|div|mod'
      };
      
      var langKeywords = keywords[lang] || '';
      if (langKeywords) {
        patterns.push({ 
          regex: new RegExp('\\b(' + langKeywords + ')\\b', 'g'), 
          className: 'hljs-keyword' 
        });
      }
      
      // Function calls
      patterns.push({ 
        regex: /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*(?=\()/g, 
        className: 'hljs-title function_' 
      });
      
      // Apply all patterns with markers to avoid re-processing
      var markerIndex = 0;
      var markers = {};
      
      patterns.forEach(function(pattern) {
        result = result.replace(pattern.regex, function(match) {
          var marker = '\x00MARKER' + markerIndex + '\x00';
          markers[marker] = '<span class="' + pattern.className + '">' + match + '</span>';
          markerIndex++;
          return marker;
        });
      });
      
      // Replace markers with actual HTML (markers use null bytes which are safe for simple replace)
      for (var marker in markers) {
        // Use split/join for better performance than regex for simple string replacement
        result = result.split(marker).join(markers[marker]);
      }
      
      return result;
    }
  };
  
  window.hljs = hljs;
})();
